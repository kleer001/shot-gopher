#!/usr/bin/env python3
"""Shot Gopher - Simple TUI for the VFX pipeline.

A friendly interface for running the shot-gopher VFX pipeline.
Works on Windows, macOS, and Linux.
"""

import os
import sys
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parent
sys.path.insert(0, str(REPO_ROOT / "scripts"))

from pipeline_constants import STAGES, STAGE_ORDER


STAGE_OUTPUT_DIRS = {
    "ingest": "source/frames",
    "interactive": "roto",
    "depth": "depth",
    "roto": "roto",
    "matanyone": "matte",
    "cleanplate": "cleanplate",
    "colmap": "colmap",
    "mocap": "mocap",
    "gsir": "gsir",
    "camera": "camera",
}


def clear_screen():
    """Clear terminal screen (Windows and Unix compatible)."""
    os.system('cls' if os.name == 'nt' else 'clear')


def print_banner():
    """Print the Shot Gopher banner."""
    banner = """
   _____ _           _      _____             _
  / ____| |         | |    / ____|           | |
 | (___ | |__   ___ | |_  | |  __  ___  _ __ | |__   ___ _ __
  \\___ \\| '_ \\ / _ \\| __| | | |_ |/ _ \\| '_ \\| '_ \\ / _ \\ '__|
  ____) | | | | (_) | |_  | |__| | (_) | |_) | | | |  __/ |
 |_____/|_| |_|\\___/ \\__|  \\_____|\\___/| .__/|_| |_|\\___|_|
                                       |_|  VFX Pipeline
"""
    print(banner)


def check_stage_complete(project_dir: Path, stage: str) -> bool:
    """Check if a stage has output files."""
    output_subdir = STAGE_OUTPUT_DIRS.get(stage)
    if not output_subdir:
        return False

    output_path = project_dir / output_subdir
    if not output_path.exists():
        return False

    png_files = list(output_path.glob("**/*.png"))
    exr_files = list(output_path.glob("**/*.exr"))

    return len(png_files) > 0 or len(exr_files) > 0


def get_completed_stages(project_dir: Path) -> set:
    """Get set of stages that have output."""
    completed = set()
    for stage in STAGE_ORDER:
        if check_stage_complete(project_dir, stage):
            completed.add(stage)
    return completed


def print_stages_menu(completed_stages: set = None):
    """Print the stages menu with completion status."""
    completed_stages = completed_stages or set()

    print("\n  Stages:")
    print("  " + "-" * 55)

    for i, stage in enumerate(STAGE_ORDER, 1):
        desc = STAGES[stage]
        check = "[done]" if stage in completed_stages else "      "
        print(f"  {i:2}. {check} {stage:12} {desc}")

    print("  " + "-" * 55)
    print("   a. ALL stages")
    print("   q. Quit")
    print()


def get_existing_projects() -> list:
    """Get list of existing project directories."""
    from env_config import DEFAULT_PROJECTS_DIR

    if not DEFAULT_PROJECTS_DIR.exists():
        return []

    projects = []
    for item in sorted(DEFAULT_PROJECTS_DIR.iterdir()):
        if item.is_dir() and (item / "source").exists():
            projects.append(item)

    return projects


def print_projects_menu(projects: list):
    """Print list of existing projects."""
    print("\n  Existing Projects:")
    print("  " + "-" * 60)

    if not projects:
        print("    (no projects found)")
    else:
        for i, proj in enumerate(projects, 1):
            completed = get_completed_stages(proj)
            if completed:
                stages_str = ", ".join(sorted(completed))
            else:
                stages_str = "(no stages run)"
            print(f"  {i:2}. {proj.name}")
            print(f"      {stages_str}")

    print("  " + "-" * 60)
    print("   n. New project from movie file")
    print("   p. Enter path manually")
    print("   q. Quit")
    print()


def get_input_path():
    """Get input path from user."""
    projects = get_existing_projects()

    print_projects_menu(projects)

    while True:
        try:
            selection = input("  Select: ").strip().lower()
        except EOFError:
            return None

        if selection == 'q':
            return None

        if selection == 'n':
            return get_movie_path()

        if selection == 'p':
            return get_manual_path()

        if projects and selection.isdigit():
            idx = int(selection) - 1
            if 0 <= idx < len(projects):
                return projects[idx]
            print(f"    Invalid number (1-{len(projects)})\n")
            continue

        print("    Invalid selection\n")


def get_movie_path():
    """Get path to movie file for new project."""
    print("\n  Enter path to movie file:")
    print("    - 'b' to go back")
    print()

    while True:
        try:
            path_str = input("  Movie: ").strip()
        except EOFError:
            return None

        if not path_str:
            print("    Please enter a path\n")
            continue

        if path_str.lower() == 'b':
            return get_input_path()

        if path_str.lower() == 'q':
            return None

        path_str = path_str.strip('"').strip("'")
        path = Path(path_str).expanduser().resolve()

        if not path.exists():
            print(f"    Not found: {path}\n")
            continue

        if not path.is_file():
            print(f"    Not a file: {path}\n")
            continue

        return path


def get_manual_path():
    """Get manual path input."""
    print("\n  Enter path to:")
    print("    - Movie file (new project)")
    print("    - Project folder (existing)")
    print("    - 'b' to go back")
    print()

    while True:
        try:
            path_str = input("  Path: ").strip()
        except EOFError:
            return None

        if not path_str:
            print("    Please enter a path\n")
            continue

        if path_str.lower() == 'b':
            return get_input_path()

        if path_str.lower() == 'q':
            return None

        path_str = path_str.strip('"').strip("'")
        path = Path(path_str).expanduser().resolve()

        if not path.exists():
            print(f"    Not found: {path}\n")
            continue

        return path


def parse_stage_selection(selection: str) -> list:
    """Parse user stage selection into list of stages."""
    stages = []

    for part in selection.split(','):
        part = part.strip()
        if not part:
            continue

        if '-' in part:
            start, end = part.split('-', 1)
            start_idx = int(start) - 1
            end_idx = int(end)
            if start_idx < 0 or end_idx > len(STAGE_ORDER):
                raise ValueError(f"Range {part} out of bounds")
            stages.extend(STAGE_ORDER[start_idx:end_idx])
        else:
            idx = int(part) - 1
            if idx < 0 or idx >= len(STAGE_ORDER):
                raise ValueError(f"Stage {part} out of bounds (1-{len(STAGE_ORDER)})")
            stages.append(STAGE_ORDER[idx])

    return stages


def get_stage_selection(completed_stages: set = None):
    """Get stage selection from user."""
    print_stages_menu(completed_stages)

    while True:
        try:
            selection = input("  Select (e.g. 1,3,4 or 2-5 or 'a'): ").strip().lower()
        except EOFError:
            return None

        if selection == 'q':
            return None

        if selection == 'a':
            return STAGE_ORDER.copy()

        if not selection:
            print("    Please make a selection\n")
            continue

        try:
            stages = parse_stage_selection(selection)
            if stages:
                return stages
            print("    No stages selected\n")
        except ValueError as e:
            print(f"    Invalid: {e}")
            print("    Use: 1,2,3 or 1-5 or 'a' for all\n")


def get_project_name(input_path: Path) -> str:
    """Get project name for new project."""
    default_name = input_path.stem.replace(" ", "_").replace("-", "_")

    print(f"\n  Project name [{default_name}]: ", end="", flush=True)
    try:
        name = input().strip()
    except EOFError:
        name = ""

    return name if name else default_name


def confirm_run(project_dir: Path, stages: list) -> bool:
    """Confirm before running."""
    print("\n  " + "=" * 50)
    print("  Ready to run:")
    print("  " + "=" * 50)
    print(f"  Project: {project_dir}")
    print(f"  Stages:  {', '.join(stages)}")
    print()

    try:
        response = input("  Proceed? [Y/n]: ").strip().lower()
    except EOFError:
        return False

    return response in ('', 'y', 'yes')


def run_pipeline(input_path: Path, stages: list, project_name: str = None):
    """Run the pipeline."""
    from run_pipeline import run_pipeline as do_run
    from env_config import DEFAULT_PROJECTS_DIR

    if input_path.is_file():
        return do_run(
            input_path=input_path,
            project_name=project_name,
            projects_dir=DEFAULT_PROJECTS_DIR,
            stages=stages,
        )
    else:
        return do_run(
            input_path=None,
            project_name=input_path.name,
            projects_dir=input_path.parent,
            stages=stages,
        )


def main():
    """Main entry point."""
    clear_screen()
    print_banner()

    print("  Welcome! Process VFX shots with ease.\n")

    input_path = get_input_path()
    if input_path is None:
        print("\n  Goodbye!")
        return 0

    if input_path.is_file():
        project_name = get_project_name(input_path)
        from env_config import DEFAULT_PROJECTS_DIR
        project_dir = DEFAULT_PROJECTS_DIR / project_name
        completed_stages = set()
    else:
        project_name = None
        project_dir = input_path
        completed_stages = get_completed_stages(project_dir)

    clear_screen()
    print_banner()

    if input_path.is_file():
        print(f"  New project: {project_name}")
        print(f"  From: {input_path.name}")
    else:
        print(f"  Project: {project_dir.name}")
        if completed_stages:
            print(f"  Completed: {', '.join(sorted(completed_stages))}")

    stages = get_stage_selection(completed_stages)
    if stages is None:
        print("\n  Goodbye!")
        return 0

    if not confirm_run(project_dir, stages):
        print("\n  Cancelled.")
        return 0

    print("\n  " + "=" * 50)
    print("  Starting pipeline...")
    print("  " + "=" * 50 + "\n")

    try:
        success = run_pipeline(input_path, stages, project_name)

        print("\n  " + "=" * 50)
        if success:
            print("  Done! Pipeline completed successfully.")
        else:
            print("  Pipeline finished with errors.")
        print("  " + "=" * 50)

        return 0 if success else 1

    except KeyboardInterrupt:
        print("\n\n  Interrupted.")
        return 130
    except Exception as e:
        print(f"\n  Error: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
